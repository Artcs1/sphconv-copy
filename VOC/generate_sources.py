
import os
import sys
import argparse
import cv2
import h5py
import numpy as np

SphConv_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(SphConv_ROOT)

import cfg
import caffe

from cfg import DATA_ROOT
from SphereProjection import SphereProjection
from VOC.VOCData import load_bboxes, IMG_SPHEREH
from util.network import load_network, forward_patch
from util.rf import kernel_sizes
from util.data_io import Logger

LOG_ROOT = os.path.join(SphConv_ROOT, "Log/gen_srcs")
if not os.path.isdir(LOG_ROOT):
    os.makedirs(LOG_ROOT)

def generate_source(path, tilt, layer , **kwargs):
    sphereH = kwargs.get('sphereH', 320)
    sphereW = sphereH * 2
    ks = kwargs.get('ks', 640)
    rf_size = kwargs.get('rf_size', 224)

    dirs, frame = os.path.split(path)
    #print(dirs)
    #print(frame)
    dirs = dirs.split("/")
    src_dir = os.path.join(DATA_ROOT, "Pano_Superpoint","train", layer)
    if not os.path.isdir(src_dir):
        os.makedirs(src_dir)
    frameId = os.path.splitext(frame)[0]
    src_path = os.path.join(src_dir, "{}.h5".format(frameId))
    if os.path.exists(src_path):
        sys.stderr.write("{} exists.\n".format(src_path))
        return
    lockfile = "{}.lock".format(src_path)
    if os.path.isfile(lockfile):
        sys.stderr.write("{} is being generated by other process.\n".format(src_path))
        return
    open(lockfile, "a").close()

    log_dir = os.path.join(LOG_ROOT, "Pano_Superpoint","train", layer)
    if not os.path.isdir(log_dir):
        os.makedirs(log_dir)
    log_path = os.path.join(log_dir, "{}.log".format(frameId))
    log = Logger(log_path)
    log.write("Generate output {}\n".format(src_path))

    # prepare projection matrix and network
    #layer = "5_3"
    print("Funciona")
    net = load_network(layer=layer, network='superpoint')
    print("dejo de funcionar")
    kernel_size = kernel_sizes[layer]
    projection = SphereProjection(kernel_size=kernel_size,
                                  sphereW=sphereW,
                                  sphereH=sphereH,
                                  imgW=ks)

    # Assume convolutional layer
    layer_name = '{}'.format(layer)
    Nch = net.params[layer_name][0].data.shape[0]
    src = np.zeros((sphereH, sphereW, Nch), dtype=np.float32)
    print(src.shape)

    log.write("Start computing convolution.\n")
    img = cv2.imread(path+'.jpg',cv2.COLOR_BGR2GRAY)
    #print(img.shape)
    if sphereH != img.shape[0]:
        #print("entro")
        img = cv2.resize(img, (sphereW, sphereH))
    #print(img.shape)
    img = img.reshape((320,640,1))
    #print(img.shape)
    for y in range(sphereH):
        P = projection.buildP(y)
        #print(P.shape)
        log.write("Process the {:>3d}-th row\n".format(y))
        log.flush()
        for x in range(sphereW):
            rimg = np.roll(img, int(projection.sphereW/2-x), axis=1)
            #print(rimg.shape)
            patch = projection.project(P, rimg)
            #print(patch.shape)
            val = forward_patch(patch, net, layer=layer)
            #print(val.shape)
            assert val.shape[2] == 1
            assert val.shape[3] == 1
            src[y,x,:] = val.ravel()

    log.write("Write output to disk.\n")
    #print(src)
    with h5py.File(src_path, 'w') as hf:
        hf.create_dataset(frameId, data=src,
                          compression="lzf",
                          shuffle=True,
                          chunks=(128, 128, Nch))
    os.remove(lockfile)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--sphereH', type=int, default=320)
    parser.add_argument('--ks', type=int, default=640)
    parser.add_argument('--rf', type=int, default=224)
    parser.add_argument('--frameId', type=str, default=None)
    parser.add_argument('--tilt', type=int, default=320)
    parser.add_argument('--layer',type=str, default = "0")
    parser.add_argument('frame', type=int, default=0)
    args = parser.parse_args()

    kwargs = {
        "sphereH": args.sphereH,
        "view_angle": 65.5,
        "ks": args.ks,
        "rf_size": args.rf,
    }
    orig_tilt = args.tilt * IMG_SPHEREH / args.sphereH
    path =  os.path.expanduser("~/Desktop/Spherical-Convolution-master/SphereImages/train/")+str(args.frame)
    print(path)
    generate_source(path, args.tilt, args.layer, **kwargs)

if __name__ == "__main__":
    main()
